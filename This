 Name: Olivia Foster
 Company: Belcan
 Journal Period: FROM June 2, 2025 TO June 13, 2025
 Total Hours Worked this Period: 71.5

Monday, June 2 (hours worked: 8)
Morning: After correctly setting up Visual Studio Community 2019, Mark walked me through the in-house created diagrammer extension. He instructed me to practice making editor files, diagrams, and exploring the import/export tool as these were all relevant to the adapter work I’d been completing. I was to complete this practice using real datasets already provided to me. Additionally, I was given a secure account to view and complete a company specific training on FACE principles. In the morning I began working on this training. 
Afternoon: The first half of the afternoon consisted of me finishing the training and asking follow up questions. The second half of the afternoon I began practice making editor files. I was able to make 2 with corresponding diagrams. The reason why this creation process was slow was because I kept getting the same error message and then would get kicked out of the program. I did try using Visual Studio’s debugger to step through the code but still was unable to find the exact misstep. I sent an email to Mark before EOD to get clarification.

Tuesday, June 3 (hours worked: 7.5)
Morning: I began the morning reading Mark’s response and realized the error was because of me trying to create the editor file before loading in the data. I correctly loaded the data and it worked like a charm. I was then able to move on to using the import/export tool to practice making custom diagrams from buffer schema’s. I created a pipeline starting with .fbs, into my adapter, to other requested formats, to the diagrammer tool to get a feel of the flow of events. 
Afternoon: In the afternoon, Mark sent me some upcoming requirements for the tool and let me know this would be the work I’d be helping support. I went through these requirements and added an ‘Olivia’s Comments and Q’s’ column and an ‘Assumed Steps’ column. In these columns I shared my questions as well as assumptions about how I would complete the work. I sent this to Mark for review and further researched reqs 1 and 4 (the ones I was most confident of) while waiting for his response. I got started on 1a, which was adding in a flatbuffer to the protobuf adapter to the tool (which I’d already programmed; I just had to figure out how to add in). I received his response by end of day and created a game plan of where I’d start/how I’d progress and shared with him. 

Wednesday, June 4 (hours worked: 8)
Morning: I spent the morning conducting a thorough code walkthrough to familiarize myself with the existing architecture and identify the optimal integration points for my adapter implementation. This involved analyzing the current data flow patterns, understanding the existing interfaces, and mapping out where my adapter would fit most seamlessly into the overall system design. Additionally, I made significant structural changes to my adapter, transforming it from a standalone independent program into an integrated component of the larger system. This refactoring eliminated the need for local file I/O operations, as the adapter would now work directly within memory data structures rather than loading files from local directories and storing outputs back to the filesystem.
Afternoon: I dedicated the afternoon to studying the ZeroMQ documentation in preparation for developing another adapter. This involved reviewing the core concepts of ZeroMQ messaging patterns, understanding the different socket types and their use cases, and examining code examples to grasp best practices for implementation. I focused particularly on understanding how ZeroMQ handles message queuing, routing, and reliability features that would be relevant to our schema adaptation requirements.

Thursday, June 5 (hours worked: 8)
Morning: I began the day by diving deep into the FastDDS documentation to understand its architecture and capabilities. FastDDS is a high-performance publish-subscribe framework, so I studied its data distribution service concepts, quality of service settings, and schema definition requirements. Following this research, I started designing a rudimentary .fbs to FastDDS schema adapter, outlining the key components needed to translate FlatBuffer schema definitions into FastDDS-compatible data types and structures. This initial design phase involved identifying the mapping relationships between FlatBuffer types and FastDDS IDL constructs.
Afternoon: I continued my documentation review, this time focusing more intensively on ZeroMQ's advanced features and implementation patterns. Building on my morning's FastDDS work, I began developing a preliminary design for a .fbs to ZeroMQ schema adapter. This design process required understanding how to bridge the gap between FlatBuffer's binary serialization format and ZeroMQ's flexible messaging patterns. I sketched out the core adapter logic, considering how to handle different message types, routing requirements, and the overall data transformation pipeline.

Friday, June 6 (hours worked: 8)
Morning: I kicked off the morning by working through the FastDDS "Hello World" tutorial, which provided hands-on experience with setting up a basic publisher-subscriber system. This tutorial helped me understand the practical aspects of FastDDS implementation, including how to define data types, create publishers and subscribers, and handle the communication lifecycle. The exercise gave me valuable insight into the framework's initialization process and basic messaging patterns that would inform my adapter design.
Afternoon: Building on the morning's tutorial, I developed a more sophisticated example that simulates a scheduling service to better understand FastDDS's capabilities in a realistic scenario. This involved creating multiple data types, implementing more complex communication patterns, and handling various message flows that would be typical in a production environment. After completing this work, I committed all of my progress to my dedicated branch (ofosterBranch) in the repository, ensuring that my code was properly versioned and accessible for review and collaboration.

Monday, June 9 (hours worked: 0)
Morning: N/A - Was out of office.
Afternoon: N/A - Was out of office.

Tuesday, June 10 (hours worked: 8)
Morning: I participated in advanced C++ training that covered sophisticated language features and modern programming techniques. The training focused on topics such as advanced template programming, memory management strategies, concurrent programming patterns, and performance optimization techniques. This knowledge directly supports my ongoing work with various messaging frameworks and schema adapters, as many of these systems are implemented in C++ and require understanding of advanced language features for effective integration and customization.
Afternoon: I completed a comprehensive feature engineering course that provided insights into data preprocessing, transformation techniques, and feature selection methodologies. The course covered topics such as handling missing data, creating derived features, normalization techniques, and dimensionality reduction approaches. This knowledge is valuable for understanding how data flows through our various adapter systems and how to optimize data representations for different messaging protocols and serialization formats.

Wednesday, June 11 (hours worked: 8)
Morning: I worked through a computer graphics course that had been recommended to me earlier in my co-op placement. The course covered fundamental concepts in computer graphics including coordinate systems, transformations, rendering pipelines, and mathematical foundations for 2D and 3D graphics. Topics included vector mathematics, matrix operations, color theory, and basic algorithms for rendering geometric shapes and handling visual effects.
Afternoon: I applied the mathematical concepts learned in the morning by implementing a practical graphics demonstration using pygame. The project involved creating a dynamic visual simulation featuring multiple colored shapes that move in coordinated sequences while implementing collision detection with boundary walls. The shapes bounce realistically off the created barriers, demonstrating physics simulation principles. After completing the graphics program, I used pyinstaller to package the application into a standalone executable file, making it easily distributable and runnable on systems without Python installations.

Thursday, June 12 (hours worked: 8)
Morning: I explored osdev.org to gain foundational knowledge about operating system development concepts, which provided valuable background for understanding low-level system interactions that are relevant to messaging frameworks. Following this research, I studied the nanomsg documentation thoroughly to prepare for developing another schema adapter. Nanomsg is a socket library that provides several common communication patterns, so I focused on understanding its API, supported protocols, and how it differs from other messaging solutions like ZeroMQ in terms of design philosophy and implementation approaches.
Afternoon: Building on my morning research, I began the architectural design phase for a .fbs to nanomsg schema adapter. This involved mapping out how FlatBuffer schema definitions would translate to nanomsg message structures, considering the library's various transport mechanisms and protocol patterns. I outlined the core adapter components, data transformation logic, and integration points that would be needed to create a seamless bridge between FlatBuffer serialization and nanomsg's communication patterns.

Friday, June 13 (hours worked: 8)
Morning: I began development of a robot coordination system implemented in C#, designed to demonstrate distributed communication patterns. The system architecture involves two autonomous robots that continuously publish their status information (including position, battery level, and operational state) to a central controller. The controller processes this incoming telemetry data and responds by issuing movement commands to coordinate the robots' actions within a 2D coordinate plane, ensuring they work together effectively without collisions or conflicts.
Afternoon: I prepared comprehensive onboarding materials and a structured learning plan for a new co-op who will be joining my project team. This involved documenting my current progress, and creating tutorial materials.I met with the incoming co-op to walk through the project objectives, demonstrate the systems I've built, and outline the planned learning progression. After the meeting, I returned to debugging the robot coordination system, specifically focusing on resolving a publishing error where one of the robots was failing to properly transmit its status updates to the central controller. I spent considerable time tracing through the communication protocol and ultimately identified and fixed the root cause of the publishing failure.

Comments: It’s been a good two weeks! I learn a ton everyday:) 


